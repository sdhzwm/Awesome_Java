## 事务
### 1. 事务

#### 1. 什么是事务

> : 在实际的开发过程中，一个业务操作如:转账，往往是要多次访问数据库才能完成的。转账是一个用户扣钱，另一个用户加钱。如果其中有一条SQL语句出现异常，这条SQL就可能执行失败。
> 事务执行是一个整体，所有的SQL语句都必须执行成功。如果其中有1条SQL语句出现异常，则所有的SQL语句都要回滚，整个业务执行失败。

#### 2. 案例
例如：

```sql
-- 创建数据表
CREATE TABLE account (
   id INT PRIMARY KEY AUTO_INCREMENT,
   NAME VARCHAR(10),
   balance DOUBLE
);
-- 添加数据
INSERT INTO account (NAME, balance) VALUES ('张三', 1000), ('李四', 1000);

-- 模拟张三给李四转 500 元钱，一个转账的业务操作最少要执行下面的 2 条语句: 

-- 张三账号-500
update account set balance = balance - 500 where name='张三'; -- 李四账号+500
update account set balance = balance + 500 where name='李四';

```
假设当张三账号上-500 元,服务器崩溃了。李四的账号并没有+500 元，数据就出现问题了。我们需要保证其中 一条SQL语句出现问题，整个转账就算失败。只有两条SQL都成功了转账才算成功。这个时候就需要用到事务.
#### 3. 事务类型
MYSQL 中可以有两种方式进行事务的操作: 

- 手动提交事务
- 自动提交事务

### 2. 手动提交事务

#### 1. SQL操作

1. 开启事务： start transaction;
2. 回滚：rollback;
3. 提交：commit;

#### 2. 使用过程

1. 执行成功的情况: 开启事务 -> 执行多条SQL语句 -> 成功提交事务
2. 执行失败的情况: 开启事务 -> 执行多条SQL语句 -> 事务的回滚
    ![](https://imagerepos.oss-cn-beijing.aliyuncs.com/images/20190927101936.png)

### 3. 自动提交事务
MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕 自动提交事务，MySQL 默认开始自动提交事务

**修改事务的默认提交方式**
- 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
- 修改默认提交方式： set @@autocommit = 0;

### 4. 事务原理

事务开启之后, 所有的操作都会临时保存到事务日志中, 事务日志只有在得到commit命令才会同步到数据表中，其他任何情况都会清空事务日志(rollback，断开连接)

![](https://imagerepos.oss-cn-beijing.aliyuncs.com/images/20190927102732.png)

- 客户端连接数据库服务器，创建连接时创建此用户临时日志文件
- 开启事务以后，所有的操作都会先写入到临时日志文件中
- 所有的查询操作从表中查询，但会经过日志文件加工后才返回
- 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件。


### 5. 回滚点

> 1. 什么是回滚点

在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。可以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为回滚点。

> 回滚点的操作语句

- 设置回滚点:savepoint 名字
- 回到回滚点:rollback to 名字

### 6. 事务的隔离级别
#### 1. 四大特征
| 事务特征| 含义|
| ---- | ---- |
|   原子性(Atomicity)   |   每个事务都是一个整体，是不可分割的最小操作单位，要么同时成功，要么同时失败。   |
|  一致性(Consistency)    |  事务操作前后，数据总量不变    |
|  隔离性(Is olation)    |  多个事务之间,互不影响，相互独立    |
|  持久性(Durabilty)    |  当事务提交或回滚后，数据库会持久化的保存数据   |

#### 2. 事务隔离级别
事务在操作时的理想状态: 所有的事务之间保持隔离，互不影响。因为并发操作，多个用户同时访问同一个 数据。可能引发并发访问的问题

| 并发访问的问题| 含义|
| ---- | ---- |
|   脏读  |   一个事务读取到了另一个事务中尚未提交的数据   |
|  不可重复读  |  一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这 是事务 update 时引发的问题    |
|  幻读   |  一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致的，这是 insert 或 delete 时引发的问题    |

#### 3.  MySQL 数据库有四种隔离级别
| 级别| 名字| 隔离级别| 脏读 | 不可重读读 | 幻读 | 数据库默认隔离级别 | 
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|   1  |   读未提交 |  read uncommitted  |   是 |  是 |   是 |  -  |  |   2  |   读已提交 |  read committed  |   否 |  是 |   是 |  Oracle 和 SQL Server  |  
|   3  |   可重复读 |  repeadtable read  |   否 |  否 |   是 |  MySQL |  
|   4  |   串行化 |  serializable  |   否 |  否 |   否 |  -  |   

> 隔离级别越高，性能越差，安全性越高。
